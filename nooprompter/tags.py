"""Tag discovery and substitution for template processing"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_tags.ipynb.

# %% ../nbs/02_tags.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['TAG_PATTERN', 'discover_tags', 'discover_tags_in_file', 'discover_tags_in_templates', 'substitute_tags',
           'substitute_tags_in_file']

# %% ../nbs/02_tags.ipynb 4
import re
from pathlib import Path


# %% ../nbs/02_tags.ipynb 7
# Tag pattern: <Tag-Name> where Tag-Name can contain letters, numbers, hyphens, and underscores
TAG_PATTERN = re.compile(r'<([A-Za-z0-9_-]+)>')


# %% ../nbs/02_tags.ipynb 8
def discover_tags(text: str) -> set[str]:
    "Find all <Tag> patterns in text"
    return set(TAG_PATTERN.findall(text))

# %% ../nbs/02_tags.ipynb 10
def discover_tags_in_file(path: str | Path) -> set[str]:
    "Find all tags in a file, return empty set on error"
    try:
        with open(Path(path), 'r', encoding='utf-8') as f:
            return discover_tags(f.read())
    except Exception:
        return set()

# %% ../nbs/02_tags.ipynb 12
def discover_tags_in_templates(template_dir: str | Path, extensions: list[str] | None = None) -> dict[str, set[str]]:
    """
    Discover all tags in template files
    Returns dict mapping file paths to sets of tags found in each file
    """
    template_dir = Path(template_dir)
    if not template_dir.exists(): return {}
    # Default to common text extensions
    if extensions is None: extensions = ['.md', '.txt', '.mdc']
    result = {}
    for ext in extensions:
        for file_path in template_dir.rglob(f'*{ext}'):
            if file_path.is_file():
                try:
                    tags = discover_tags_in_file(file_path)
                    if tags:  # Only include files with tags
                        result[str(file_path.relative_to(template_dir))] = tags
                except Exception: pass
    return result

# %% ../nbs/02_tags.ipynb 15
def substitute_tags(
    text: str,            # Text containing tags to substitute
    tags: dict[str, str], # Dictionary mapping tag names to values
    max_depth: int = 10,  # Maximum recursion depth for nested tags
    warn_missing: bool = False # If True, print warnings for missing tags
) -> str:
    "Recursively substitute tags in text"
    result = text
    depth = 0
    
    while depth < max_depth:
        found_tags = discover_tags(result)
        if not found_tags: break
        
        missing = found_tags - set(tags.keys())
        if missing:
            if warn_missing: print(f"Warning: Missing tags: {missing}")
        
        made_substitution = False
        for tag in found_tags:
            if tag in tags:
                result = result.replace(f'<{tag}>', str(tags[tag]))
                made_substitution = True
        
        if not made_substitution: break
        depth += 1
    
    # Hit max depth - warn and return what we got
    if depth >= max_depth and discover_tags(result):
        remaining = discover_tags(result)
        print(f"Warning: Max recursion depth ({max_depth}) reached. Unresolved tags: {remaining}")
    
    return result

# %% ../nbs/02_tags.ipynb 18
def substitute_tags_in_file(
    src: str | Path,          # Source file path
    dst: str | Path,          # Destination file path
    tags: dict[str, str],     # Dictionary mapping tag names to values
    **options                 # Additional options for substitute_tags (strict, max_depth, warn_missing)
) -> None:
    "Process file with tag substitution and write to destination"
    src, dst = Path(src), Path(dst)
    if not src.exists(): raise FileNotFoundError(f"Source file not found: {src}")
    with open(src, 'r', encoding='utf-8') as f: text = f.read()
    result = substitute_tags(text, tags, **options)
    dst.parent.mkdir(parents=True, exist_ok=True)
    with open(dst, 'w', encoding='utf-8') as f: f.write(result)
